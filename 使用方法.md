# 在 `indicators.py` 里实现你的逻辑函数

根据你希望的输入选择两种模式：

- **整表输入（`kind='df'`）**：函数拿到整张 `df`（含 `open/high/low/close/vol` 等），适合做多条件组合/交叉信号；返回 **Series**（单列）或 **DataFrame**（多列）。
- **收盘价序列（`kind='series_close'`）**：函数只接收 `close` 序列，适合纯价信号；返回 Series / (Series 列表)。

> 引擎会按返回类型自动写列：返回 DataFrame → 把各列直接并入；返回 (list/tuple) → 需和注册表里的 `out` 列名个数**一致**；返回 Series/ndarray → 写到单列。若数量不匹配会跳过并告警。

**示例 A：放量突破 + 金叉 组合信号（多列返回）**

```
# indicators.py
import pandas as pd

def logic_combo(df: pd.DataFrame, n_break=20, vol_win=20, ma_s=5, ma_l=20):
    close = df["close"].astype(float)
    high  = df["high"].astype(float)
    vol   = df["vol"].astype(float)

    ma_short = close.rolling(ma_s).mean()
    ma_long  = close.rolling(ma_l).mean()
    golden   = (ma_short > ma_long) & (ma_short.shift(1) <= ma_long.shift(1))
    death    = (ma_short < ma_long) & (ma_short.shift(1) >= ma_long.shift(1))

    breakout = close > high.rolling(n_break).max().shift(1)
    vol_spike = vol > vol.rolling(vol_win).mean() * 1.5

    signal = (golden & breakout & vol_spike).astype("int8")  # 1/0 信号
    # 返回多列：均线/事件/综合信号，便于下游分析
    return pd.DataFrame({
        "ma_s": ma_short,
        "ma_l": ma_long,
        "golden_cross": golden.astype("int8"),
        "death_cross":  death.astype("int8"),
        "breakout":     breakout.astype("int8"),
        "vol_spike":    vol_spike.astype("int8"),
        "logic_signal": signal,
    })
```

**示例 B：只返回单列布尔信号**

```
def breakout_signal(df, n=55):
    high = df["high"].astype(float)
    close = df["close"].astype(float)
    sig = (close > high.rolling(n).max().shift(1)).astype("int8")
    return sig  # 单列
```

**示例 C：仅收盘价的逻辑（series_close）**

```
def upstreak(close, k=5):
    return (close > close.shift(1)).rolling(k).sum().fillna(0).astype("int8")
```

------

# 把新函数注册到 `INDICATOR_REGISTRY`

在 `download_merged.py` 的注册表里追加条目，声明 **输入类型**、**输出列名**、**默认参数**：

```
python复制编辑INDICATOR_REGISTRY.update({
    "logic_combo": {
        "kind": "df",
        # 多列返回时，这里写不写都行：返回 DataFrame 会被逐列合并
        "out": "dataframe",
        "kwargs": {"n_break": 20, "vol_win": 20, "ma_s": 5, "ma_l": 20},
    },
    "breakout_signal": {
        "kind": "df",
        "out": "breakout_sig",              # 单列名
        "kwargs": {"n": 55},
    },
    "upstreak": {
        "kind": "series_close",
        "out": "upstreak_5",
        "kwargs": {"k": 5},
    },
})
```

> 脚本会根据 `INDICATOR_REGISTRY` 逐个计算并把新列写入 **by_symbol 成品 parquet**。
>  选择哪些指标参与计算由 `SYMBOL_PRODUCT_INDICATORS` 控制：设为 `"all"` 就计算全表，或写成 `"rsi,macd,logic_combo"` 仅算指定集合