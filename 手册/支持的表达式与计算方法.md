# 预测模块和排名模块支持的描述表达式

本文档列出除 `tdx_compat.py` 中已注册函数外，预测模块和排名模块额外支持的描述表达式及其计算方法。

## 1. 动态列名支持

### 1.1 DataFrame 列的自动注入

**功能说明**：系统会自动将 DataFrame 中的每个数值列作为变量注入表达式上下文。

**注入规则**：
- 每个列名会自动创建小写和大写两个版本
- 例如：如果 DataFrame 有列 `close`、`high`、`low`、`open`，则可使用：
  - `close`、`Close`、`CLOSE`
  - `high`、`High`、`HIGH`
  - 等等

**计算方法**：
```python
# 从 predict_core.py 的 _build_eval_ctx 函数
for col in sub.columns:
    if col in skip:
        continue
    s = pd.to_numeric(sub[col], errors="coerce")
    if s.notna().sum() == 0:
        continue
    arr = s.values
    name = str(col)
    up = name.upper()
    if name not in ctx:
        ctx[name] = arr
    if up not in ctx:
        ctx[up] = arr
```

**使用示例**：
```tdx
C > MA(C, 20)
close > MA(close, 20)
HIGH > LOW * 1.05
```

### 1.2 价格数据简写别名

**支持的别名**：
| 别名 | 实际列名 | 说明 |
|------|---------|------|
| O | open | 开盘价 |
| H | high | 最高价 |
| L | low | 最低价 |
| C | close | 收盘价 |
| V | vol | 成交量 |

**计算方法**：
```python
alias = {"O": "open", "H": "high", "L": "low", "C": "close", "V": "vol"}
for k, base in alias.items():
    if k not in ctx and base in sub.columns:
        ctx[k] = pd.to_numeric(sub[base], errors="coerce").values
```

**使用示例**：
```tdx
C > O
H - L > C * 0.02
V > MA(V, 20) * 1.5
```

### 1.3 指标列的别名支持

**支持的情况**：
- KDJ指标：`j`、`k`、`d` 会自动查找列名：`j`、`J`、`kdj_j`、`KDJ_J`、`k`、`K`、`kdj_k`、`KDJ_K` 等
- 如果列不存在，会自动触发兜底计算

**计算方法**：
```python
def _ensure_alias(dst_name: str, cand_names: list[str]):
    """确保别名在上下文中可用"""
    if dst_name in ctx:
        return
    for c in cand_names:
        if c in sub.columns:
            arr = pd.to_numeric(sub[c], errors="coerce").values
            ctx[dst_name] = arr
            ctx[dst_name.lower()] = arr
            ctx[dst_name.upper()] = arr
            return
    # 如果都不存在，使用兜底计算
    kdj = _fallback_kdj(sub)
    arr = pd.to_numeric(kdj[dst_name.lower()], errors="coerce").values
    ctx[dst_name] = arr
    ctx[dst_name.lower()] = arr
    ctx[dst_name.upper()] = arr
```

## 2. 指标系统支持

### 2.1 已注册指标（indicators.py REGISTRY）

以下指标已在系统中注册，可在表达式中直接使用：

| 指标名称 | 输出列 | 计算方法 | 说明 |
|---------|--------|---------|------|
| kdj | j | RSV(C,H,L,9); K=SMA(RSV,3,1); D=SMA(K,3,1); J=3*K-2*D | KDJ指标 |
| volume_ratio | vr | V / MA(V, 20) | 量比 |
| bbi | bbi | (MA(C,3)+MA(C,6)+MA(C,12)+MA(C,24))/4 | 多空指数 |
| rsi | rsi | SMA(MAX(C-REF(C,1),0),N,1) / SMA(ABS(C-REF(C,1)),N,1) * 100 | RSI相对强弱指标 |
| bupiao | bupiao_short, bupiao_long | 100*(C-LLV3)/(HHV3-LLV3) | 布漂指标 |
| shuangjunxian | bar_color | 基于均价和均量的涨跌关系 | 双均线K线颜色（1=绿，2=红，3=黄） |
| duokong_short | duokong_short | EMA(EMA(C,10),10) | 知行多空线（短期） |
| duokong_long | duokong_long | (MA(C,14)+MA(C,28)+MA(C,57)+MA(C,114))/4 | 知行多空线（长期） |
| z_score | z_score | 2*EMA(Zscore((C-O)/O*100),5) × min(V/MA(V,20),2) | Z优化评分 |
| DIFF | diff | EMA(C,12) - EMA(C,26) | MACD-DIFF |

**使用示例**：
```tdx
j < 13
rsi > 70
diff > 0
duokong_short > duokong_long
```

### 2.2 指标列的动态扫描

**功能说明**：表达式解析时，系统会自动检测引用的指标，并加载对应的列。

**扫描逻辑**（来自 scoring_core.py 的 `_scan_cols_from_expr`）：
```python
def _scan_cols_from_expr(expr: str) -> list[str]:
    """从表达式里扫出可能需要的列"""
    need = {"trade_date", "open", "high", "low", "close", "vol", "amount"}
    
    # 动态扫描所有指标
    from indicators import REGISTRY
    for indicator_name, meta in REGISTRY.items():
        # 检查表达式是否包含该指标名
        if (_expr_mentions(expr, indicator_name) or 
            _expr_mentions(expr, indicator_name.upper()) or
            _expr_mentions(expr, indicator_name.lower())):
            # 添加输出列名
            for output_col in meta.out.keys():
                need.add(output_col)
        
        # 检查是否直接包含输出列名
        for output_col in meta.out.keys():
            if (_expr_mentions(expr, output_col) or 
                _expr_mentions(expr, output_col.upper()) or
                _expr_mentions(expr, output_col.lower())):
                need.add(output_col)
    
    return sorted(need)
```

## 3. 动态变量上下文

### 3.1 TS（股票代码）

**变量名**：`TS` 或 `ts_code`

**说明**：当前处理的股票代码

**注入位置**：
```python
tdx.EXTRA_CONTEXT.update({"TS": ts, "REF_DATE": str(sim_date)})
```

**使用示例**：
```tdx
# 某些特定逻辑中可能用到
# 通常通过 DataFrame 分组来处理不同股票
```

### 3.2 REF_DATE（参考日期）

**变量名**：`REF_DATE` 或 `ref_date`

**说明**：当前判断的参考日期

**计算方法**：从表达式调用时传入

### 3.3 自定义标签系列（ANY_TAG）

**支持的函数**：
- `ANY_TAG(pattern, shift=0)` - 匹配标签
- `YDAY_ANY_TAG(pattern)` - 昨日任意标签
- `TAG_HITS(pattern, shift=0)` - 标签命中数
- `ANY_TAG_AT_LEAST(pattern, k, shift=0)` - 至少命中k个标签
- `YDAY_TAG_HITS(pattern)` - 昨日标签命中数
- `YDAY_ANY_TAG_AT_LEAST(pattern, k)` - 昨日至少命中k个标签

**功能说明**：根据标签名称模式匹配 DataFrame 列或自定义标签。

**计算方法**：
```python
def ANY_TAG(pattern: str, shift: int = 0):
    """在DF列名里查找匹配pattern的列，逐列转布尔后做OR"""
    df = EXTRA_CONTEXT.get("DF", None)
    # 模式匹配逻辑
    is_regex = bool(re.search(r"[.^$*+?{}\[\]|()]", pat))
    # 列名匹配
    cols = [c for c in df.columns if re.compile(pat, re.I).search(str(c))]
    # 自定义标签匹配
    custom = _iter_custom_tag_series(pat, df.index)
    # 合并结果
    agg = None
    for c in cols:
        s = _coerce_bool_series(df[c])
        agg = s if agg is None else (agg | s)
    # 应用shift
    if shift != 0:
        agg = agg.shift(shift).fillna(False)
    return agg

def TAG_HITS(pattern: str, shift: int = 0):
    """计数命中标签的个数"""
    # 支持精确匹配（bucket模式）、列名匹配、自定义标签匹配
    # 返回命中数量的整数序列
```

**使用示例**：
```tdx
ANY_TAG("突破")
YDAY_ANY_TAG("涨停")
TAG_HITS("涨停", shift=0) >= 2
ANY_TAG_AT_LEAST("突破", 2)
```

## 4. DataFrame 列的动态注入

### 4.1 列名识别

**实现位置**：`tdx_compat.py` 的 `_extra_ctx_from_df_columns` 函数

**计算方法**：
```python
def _extra_ctx_from_df_columns(df) -> dict:
    """为 df 的每一列建立别名：原名 + 全大写"""
    reserved = set(FUNC_MAP.keys()) | set(VAR_MAP.keys()) | {"AND","OR","NOT"}
    ctx = {}
    for col in getattr(df, "columns", []):
        if not isinstance(col, str):
            continue
        series = df[col]
        for key in (col, col.upper()):
            if key in reserved:
                continue
            if key.isidentifier():
                ctx.setdefault(key, series)
    return ctx
```

**结果**：DataFrame 的每个数值列都会作为变量注入，可以用列名直接引用。

### 4.2 列名大小写不敏感访问

系统会对每个列名提供多种大小写版本：
- 原始列名：`close`
- 大写版本：`CLOSE`
- 小写版本：`close`

**使用示例**：
```tdx
close > open
CLOSE > OPEN
Close > Open
```

## 5. 表达式语法支持

### 5.1 逻辑运算符

| 运算符 | TDX格式 | Python格式 | 说明 |
|--------|---------|-----------|------|
| 与 | AND 或 && | & | 逻辑与 |
| 或 | OR 或 \|\| | \| | 逻辑或 |
| 非 | NOT 或 ! | ~ | 逻辑非 |

**计算方法**（来自 `tdx_compat.py`）：
```python
def _replace_logicals(expr):
    for k, v in LOGICAL_MAP.items():
        expr = re.sub(rf'(?<![A-Za-z0-9_]){k}(?![A-Za-z0-9_])', v, expr, flags=re.IGNORECASE)
    expr = expr.replace("&&", "&").replace("||", "|").replace("!", "~")
    return expr
```

### 5.2 比较运算符

| 运算符 | 说明 |
|--------|------|
| == | 等于 |
| != | 不等于 |
| < | 小于 |
| <= | 小于等于 |
| > | 大于 |
| >= | 大于等于 |

**自动处理**：
- TDX 中 `=` 会自动转换为 Python 的 `==`
- 比较表达式会被自动加括号保护，避免位运算优先级问题

### 5.3 位运算支持

虽然 TDX 表达式使用逻辑运算符（AND/OR），但会被转换为 Python 的位运算符（&/|），支持向量化计算。

**处理方式**：
```python
def _wrap_comparisons_for_bitwise(expr: str) -> str:
    """在顶层 & 和 | 处分段；分段内若含比较运算，自动加括号"""
    # 扫描并保护比较表达式
    for ch in expr:
        if ch in '&|':
            # 在分段点处理
            seg = ''.join(buf).strip()
            if seg and COMP_RE.search(seg):
                seg = f'({seg})'
```

## 6. 上下文变量注入机制

### 6.1 运行时可注入变量

**实现方式**：`EXTRA_CONTEXT` 全局字典

**用途**：运行时可注入自定义函数/变量

**注入方法**：
```python
EXTRA_CONTEXT = {}  # 运行时可注入自定义函数/变量

# 运行时注入
tdx.EXTRA_CONTEXT.update({
    "CUSTOM_VAR": value,
    "CUSTOM_FUNC": custom_function
})

# 在表达式调用时合并
if EXTRA_CONTEXT:
    extra_ctx.update(EXTRA_CONTEXT)
```

### 6.2 自定义标签注入

**变量名**：`CUSTOM_TAGS`

**结构**：字典，key为标签名，value为布尔序列

**使用场景**：支持策略定义的动态标签，可在表达式中通过 `ANY_TAG` 等函数访问

## 7. 表达式解析流程

### 7.1 编译流程

1. **变量替换**（`_replace_variables`）：
   - 将 TDX 变量名（如 `C`、`O`、`H`、`L`）替换为 DataFrame 访问表达式
   
2. **函数替换**（`_replace_functions`）：
   - 将 TDX 函数名替换为 Python 函数名
   
3. **逻辑运算符替换**（`_replace_logicals`）：
   - AND → &
   - OR → |
   - NOT → ~
   
4. **等号替换**（`_replace_equality`）：
   - = → ==
   
5. **对比表达式保护**（`_wrap_comparisons_for_bitwise`）：
   - 为比较表达式自动加括号

### 7.2 执行流程

1. **上下文构造**：
   - 从 DataFrame 提取所有数值列
   - 添加别名变量
   - 合并运行时上下文
   
2. **表达式评估**：
   - 使用 `eval(expr, ctx)` 执行
   - 返回结果字典

3. **结果提取**：
   - 从结果字典提取布尔序列或最终值

## 8. 预测模块专用函数

### 8.1 时间序列排名和百分位

#### TS_RANK(x, n)

**功能**：返回每日对应"该日值在最近 n 天窗口内的名次（1..n）"

**计算方法**：
```python
def TS_RANK(x, n):
    """返回每日对应"该日值在最近 n 天窗口内的名次（1..n）" """
    import numpy as np, pandas as pd
    s = pd.Series(x)
    def rk(arr):
        last = arr[-1]
        return float((arr <= last).sum())
    return s.rolling(int(n), min_periods=1).apply(lambda a: rk(a.values), raw=False)
```

**使用示例**：
```tdx
TS_RANK(C, 60) <= 5      # 收盘价在最近60天内排名前5
TS_RANK(VOL, 20) >= 18   # 成交量在最近20天内排名后20%
```

**说明**：
- 返回值范围：1 到 n
- 1 表示最小值排名
- n 表示最大值排名

#### TS_PCT(x, n)

**功能**：返回与 x 同索引的序列，每日对应"该日值在最近 n 天窗口内的百分位（0..1）"

**计算方法**：
```python
def TS_PCT(x, n):
    """返回每日对应"该日值在最近 n 天窗口内的百分位（0..1）" """
    import numpy as np, pandas as pd
    s = pd.Series(x)
    def pct(arr):
        last = arr[-1]
        return float((arr <= last).sum()) / len(arr)
    return s.rolling(int(n), min_periods=1).apply(lambda a: pct(a.values), raw=False)
```

**使用示例**：
```tdx
TS_PCT(C, 60) < 0.1       # 收盘价处于最近60天的最低10%
TS_PCT(R, 20) > 0.9       # 收益率处于最近20天的最高10%
```

**说明**：
- 返回值范围：0.0 到 1.0
- 0.0 表示最小值位置
- 1.0 表示最大值位置
- 0.5 表示中位数位置

### 8.2 DIFF 分析专用函数

#### GET_LAST_DIFF_HIGH_PRICE(lookback_days=60)

**功能**：获取上次 DIFF 最高点时的收盘价

**参数**：
- `lookback_days`：回看天数，默认 60

**返回值**：上次 DIFF 最高点时的收盘价，如果未找到返回 0

**使用示例**：
```tdx
C > GET_LAST_DIFF_HIGH_PRICE(100)  # 当前价格超过上次DIFF最高点价格
```

#### GET_LAST_DIFF_HIGH_VALUE(lookback_days=60)

**功能**：获取上次 DIFF 最高点的数值

**参数**：
- `lookback_days`：回看天数，默认 60

**返回值**：上次 DIFF 最高点的数值，如果未找到返回 0

**使用示例**：
```tdx
DIFF > GET_LAST_DIFF_HIGH_VALUE(60)  # 当前DIFF值超过历史最高
```

#### REVERSE_PRICE_TO_DIFF(target_diff_value, method="optimize")

**功能**：反推到指定 DIFF 值时的价格

**参数**：
- `target_diff_value`：目标 DIFF 值
- `method`：求解方法（optimize/binary_search/grid_search）

**返回值**：反推的收盘价，如果失败返回当前收盘价

**计算方法**：
使用价格求解器（PriceSolver）进行数值优化，反推能使 DIFF 达到目标值的价格。

**使用示例**：
```tdx
REVERSE_PRICE_TO_DIFF(0.5)       # 反推DIFF=0.5时的价格
REVERSE_PRICE_TO_DIFF(1.0, "optimize")
```

### 8.3 KDJ 特定查找函数

#### FIND_LAST_LOWEST_J(threshold=13.0, lookback=100)

**功能**：查找上一次 KDJ 的 J 值最低点，且 J 值要低于指定阈值

**参数**：
- `threshold`：J 值阈值，默认 13.0
- `lookback`：回看天数，默认 100

**返回值**：收盘价序列，返回在 lookback 窗口内满足 threshold 条件的 J 值历史最低点对应的收盘价，用于获取买点参考价格

**逻辑说明**：
1. 对于每一天，向前回看 lookback 天
2. 在回看窗口内，找到所有 J 值低于 threshold 的数据点
3. 在这些点中，找到 J 值最小的那个点（历史最低点）
4. 返回该历史最低点对应的收盘价

**使用示例**：
```tdx
C == FIND_LAST_LOWEST_J(13, 100)  # 当前价格等于历史J值最低点价格
C > FIND_LAST_LOWEST_J(13, 100)   # 当前价格高于历史J值最低点价格，可用于买点判断
```

### 8.4 条件价格查找

#### GET_LAST_CONDITION_PRICE(condition_expr, lookback=100)

**功能**：获取上一次满足指定条件的收盘价

**参数**：
- `condition_expr`：条件表达式字符串，如 'j < 13' 或 'C > MA(C, 20)'
- `lookback`：回看天数，默认 100

**返回值**：收盘价序列，如果该日满足条件则返回当日收盘价，否则返回 NaN

**使用示例**：
```tdx
C > GET_LAST_CONDITION_PRICE("j < 13", 100)  # 当前价格超过上次J<13时的价格
GET_LAST_CONDITION_PRICE("C > MA(C,20)", 60)
```

## 9. 支持的运算符一览

### 9.1 算术运算符
- `+`：加法
- `-`：减法
- `*`：乘法
- `/`：除法

### 9.2 比较运算符
- `==`：等于（TDX中可用 `=`）
- `!=`：不等于
- `<`：小于
- `<=`：小于等于
- `>`：大于
- `>=`：大于等于

### 9.3 逻辑运算符
- `AND` 或 `&&`：逻辑与
- `OR` 或 `||`：逻辑或
- `NOT` 或 `!`：逻辑非

### 9.4 内置函数（已注册）
- `REF(x, n)`：引用N天前的值
- `MA(x, n)`：N日移动平均
- `EMA(x, n)`：N日指数移动平均
- `SMA(x, n, m)`：平滑移动平均
- `SUM(x, n)`：N日求和
- `HHV(x, n)`：N日最高值
- `LLV(x, n)`：N日最低值
- `STD(x, n)`：N日标准差
- `ABS(x)`：绝对值
- `MAX(a, b)`：最大值
- `MIN(a, b)`：最小值
- `IF(cond, a, b)`：条件判断
- `COUNT(cond, n)`：计数条件满足次数
- `CROSS(a, b)`：上穿
- `BARSLAST(cond)`：上一次条件成立的位置

## 10. 表达式示例

### 10.1 基础价格条件
```tdx
C > O                    // 收盘价大于开盘价
C > MA(C, 20)            // 收盘价大于20日均线
H - L > C * 0.02         // 振幅大于2%
```

### 10.2 指标条件
```tdx
j < 13                   // J值小于13
RSI > 70                 // RSI大于70
DIFF > 0                 // DIFF为正
```

### 10.3 组合条件
```tdx
C > MA(C, 20) AND j < 13
RSI > 70 AND V > MA(V, 20)
C > O OR HIGH > REF(HIGH, 1)
```

### 10.4 标签匹配
```tdx
ANY_TAG("突破")
YDAY_ANY_TAG("涨停") AND C > O
TAG_HITS("涨停") >= 2
```

## 11. 注意事项

1. **列名自动注入**：DataFrame 的所有数值列都会自动注入为变量，可以直接使用列名
2. **大小写不敏感**：变量名大小写不敏感，会自动创建多版本别名
3. **动态指标加载**：使用指标时会自动检查并加载需要的列
4. **表达式缓存**：表达式编译结果会缓存，提升性能
5. **安全除法**：系统支持 `SAFE_DIV` 函数，避免除零错误

## 12. 兼容性说明

- 基本兼容 TDX（通达信）语法
- 支持 Python 风格的条件表达式
- 自动处理变量和函数映射
- 支持混合大小写变量名

