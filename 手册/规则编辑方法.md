#  排名策略与表达式参考

> 适用于 `score_ui.py` 里“策略测试器（单条规则）”的 JSON 规则；也同样适用于 `config.py` 中 `SC_RULES` 的写法。

---

## 1) 最小可用模板（**必填** / **可选**）

```json
{
  "timeframe": "D",                // 可选，默认 "D"（日线）
  "window": 60,                    // 可选，默认 SC_LOOKBACK_D（config 里默认 60）
  "when": "C > MA(C, 20)",         // ✅ 必填：TDX 风格表达式（见下）
  "scope": "ANY",                  // 可选，默认 "ANY"
  "points": 0,                     // 可选：命中加/减分（默认 0）
  "explain": "示例说明"             // 可选：规则说明文字
}
```
> 说明：`when` 至少要提供一个（或用 `clauses` 多子句替代），其余字段都有默认值。

---

## 2) 字段一览

| 字段 | 类型 | 是否必填 | 取值 / 说明 |
|---|---|---|---|
| `name` | str | 可选 | 规则名，仅用于展示。 |
| `timeframe` | str | 可选 | `"D" / "W" / "M"`，默认 `"D"`（日、周、月线）。 |
| `window` | int | 可选 | 回看窗口条数，默认 `SC_LOOKBACK_D`（config 默认 60）。 |
| `when` | str | **必填** | 条件表达式（TDX 风格，见 §5）。可与 `scope` 组合决定“命中”语义。若使用 `clauses`，每个子句也需要 `when`。 |
| `scope` | str | 可选 | 命中口径，默认 `"ANY"`。详见 §3。 |
| `points` | number | 可选 | 命中时加/减分，默认 `0`。`scope="EACH"` 时会对每条命中累加。 |
| `explain` | str | 可选 | 规则解释文本，用于明细展示。 |
| `show_reason` | bool | 可选 | 是否把该规则的 `explain` 纳入“理由”列表，默认 `True`。 |
| `as` | str | 可选 | 分类标签：`"opportunity"`（机会）、`"highlight"`（高亮）、`"drawback"`（缺点）、或 `"auto"`（默认，由系统决定）。这些标签可被 `ANY_TAG*/TAG_*` 系列函数使用（§5.4）。 |
| `gate` / `trigger` / `require` | str / dict / list | 可选 | **前置门槛**。命中该门槛后才判定主体规则。可写成一个表达式字符串，或一个“子规则对象”，或“子句数组”。未显式给出时默认 `scope="LAST"`，并继承外层 `timeframe/window`。 |
| `clauses` | list | 可选 | 多子句 **AND** 组合（跨周期时需所有子句的 `timeframe/window` 一致）。详见 §4。 |
| `dist_points` / `distance_points` | list | 可选 | 仅当 `scope` 为 `RECENT`/`DIST`/`NEAR` 使用：按“最近一次命中的距离（lag，单位=该周期K线条数）”分段给分。详见 §3.3。 |

---

## 3) `scope`（命中口径）

### 3.1 基本口径
- `LAST`：仅看窗口内 **最后一根** 是否满足。  
- `ANY`：窗口内 **任意一根** 满足即命中。  
- `ALL`：窗口内 **全部** 满足才命中。  
- `COUNT>=k`：窗口内满足的 **次数** ≥ k。  
- `CONSEC>=m`：窗口内存在 **连续 m 天** 为 True。  

### 3.2 连续子窗
- `ANY_n`：在长度为 *n* 的任意 **连续子窗** 中至少 1 天为 True。  
- `ALL_n`：在长度为 *n* 的任意 **连续子窗** 中 **每天** 都为 True（等价“存在长度 n 的连续 True 段”）。  

> 以上口径均对 `when` 的布尔序列进行统计；内部实现已处理缺失为 False。

### 3.3 最近命中打分（`RECENT` / `DIST` / `NEAR`）
将 `scope` 设为 `RECENT`（或同义：`DIST`/`NEAR`）时，不直接用 `points`，而是根据 **最近一次命中的距离 `lag`**（距离窗口右端的 K 数）在 `dist_points` 表中查分：

- `dist_points` 支持两种写法：
  1) 区间三元组：`[[min, max, points], ...]`  
  2) 显式对象：`[{"min":0,"max":5,"points":+10}, ...]`  
- 运行时将计算窗口内最近一次 `when=True` 的位置，得到 `lag`，并按区间匹配到对应 `points`。无法命中时不加分。

示例：
```json
{
  "scope": "RECENT",
  "dist_points": [[0,5,+20],[6,10,+10],[11,20,+5]]
}
```

---

## 4) 多子句 `clauses`

用于“跨周期 AND 组合”的写法。规则：

- 每个子句都是一个小规则对象：需要 `timeframe/window/when`/`scope`。  
- **所有子句的 `timeframe` 与 `window` 必须一致**；系统会 **逐K合并（AND）** 后再依据 `scope` 统计命中/次数。  
- 可与 `gate` 联用：先判 `gate`，再判合并后的主体。

示例：
```json
{
  "name": "D突破+W多头",
  "clauses": [
    {"timeframe":"D","window":40,"when":"C>HHV(H,40) AND V>1.5*MA(V,20)","scope":"ANY"},
    {"timeframe":"W","window":20,"when":"MA(C,5)>MA(C,10)","scope":"LAST"}
  ],
  "points": +8,
  "explain": "日线放量突破且周线均线多头排列"
}
```

---

## 5) 表达式语法（TDX 兼容）

### 5.1 变量（大小写不敏感）
- 价格/量：`C/Close` 收盘，`O/Open` 开盘，`H/High` 最高，`L/Low` 最低，`V/Vol` 成交量，`AMOUNT` 成交额。  
- 常用指标列（若缺会自动兜底）：`J`（KDJ 的 J 值），`VR`（量比，自动按 26 日均量兜底）。  
- 自定义/合并产物：`z_slope`、`bbi`、`bupiao_short`、`bupiao_long` 等（若存在于数据列即可直接用）。

### 5.2 函数（精选）
- 统计/滑窗：`MA(x,n)`、`EMA(x,n)`、`SMA(x,n,m)`、`SUM(x,n)`、`STD(x,n)`、`HHV(x,n)`、`LLV(x,n)`、`REF(x,n)`、`BARSLAST(cond)`、`COUNT(cond,n)`、`CROSS(a,b)`、`ABS/MAX/MIN`、`SAFE_DIV(a,b)`、`RSV(C,H,L,n)`。
- 时序分位/名次：`TS_PCT(x,n)`（近 n 天分位，0~1）、`TS_RANK(x,n)`（近 n 天名次，1~n）。
- 横截面名次：`RANK_VOL(N,K?)`、`RANK_RET(N,K?, side='up'|'down')`、`RANK_MATCH_COEF(N,K?)`。

### 5.3 逻辑与比较
- 逻辑：`AND`、`OR`、`NOT`（可写成 `&`、`|`、`~`）。  
- 比较：`> >= < <= == !=`。单等号 `=` 会被自动规范为 `==`。  
- 赋值与多语句：支持 `X := ...;` 分号分隔；最后一个表达式或名为 `sig/LAST_EXPR` 的变量会作为条件输出。

### 5.4 标签函数（与 `as` 规则联动）
- `ANY_TAG("关键词|正则", shift=0)`：根据列名或 `as` 规则生成的标签，模糊匹配并 **OR** 聚合，`shift=1` 表示“引用昨日”。  
- `TAG_HITS("pattern", shift=0)`：返回整型命中次数序列，可与阈值比较。  
- `ANY_TAG_AT_LEAST("pattern", k, shift=0)` / 及其昨日版本。

> 这些函数会在当前滚动窗口内对齐索引，并可读取通过 `as` 分类计算出的 `CUSTOM_TAGS`。

---

## 6) `gate` / `trigger` / `require`（前置门槛）

- 写法：可以是一个字符串表达式（等价一个子规则），也可以是一个 **子规则对象** 或 **子句数组**。  
- 默认：若没写 `timeframe/window/scope`，门槛会 **继承外层**，并把 `scope` 视为 `"LAST"`（只看门槛在窗口的最后一根是否成立）。  
- 流程：先判 `gate` 命中，再判主体规则；若 `gate` 未通过，主体不加分。

示例：
```json
{
  "name": "破趋势",
  "timeframe": "D",
  "window": 2,
  "when": "C <= duokong_long",
  "gate": "O > duokong_long",     // 仅当当日高于趋势时，才认可“跌破”
  "scope": "LAST",
  "points": -20
}
```

---

## 7) 常见示例

- **连续条件**（三连阳）：
```json
{
  "timeframe":"D","window":20,"when":"C>MA(C,20)","scope":"CONSEC>=3","points":+4,"explain":"连续3天收盘站上MA20"
}
```

- **跨周期 AND 组合**（日线突破 + 周线多头）：见 §4 示例。

- **最近命中给分**（金叉越近分越高）：
```json
{
  "timeframe":"D","window":25,"when":"CROSS(duokong_short,duokong_long)","scope":"RECENT","dist_points":[[0,5,30],[6,20,20]],"explain":"多空金叉"
}
```

---

## 8) 注意事项 / 最佳实践

- 多子句 `clauses` 当前**不支持**在同一规则里混用不同 `timeframe/window`（需保持一致）。
- 使用 `J/VR` 时若源数据缺列，系统会自动兜底计算；默认把缺失当作 `False` 处理。
- `scope="EACH"`/`PERBAR`：对每个满足 `when=True` 的 K 线进行逐条计数并叠加 `points`。适用于“日内/逐K加权”的场景。

# 预测策略与表达式参考

## 价格相关

- `mode`：价格模式（决定“明日”的开/收如何生成）
   取值：
  - `close_pct`：开=昨收，收=昨收×(1+`pct`%)。predict_core
  - `open_pct`：开=昨收×(1+`pct`%)，收=昨收（不变）。predict_core
  - `gap_then_close_pct`：开=昨收×(1+`gap_pct`%)，收=开×(1+`pct`%)。predict_core
  - `flat`：开=收=昨收。predict_core
  - `limit_up` / `limit_down`：开=收=昨收×(1+`limit_up_pct`% / `limit_dn_pct`%)（默认 ±9.9%）。predict_core predict_core
- `pct`：涨跌幅百分比；用于 `close_pct` / `open_pct` / `gap_then_close_pct` 的**收盘段**。predict_core
- `gap_pct`：跳空百分比；仅 `gap_then_close_pct` 使用（先按它定“开盘”）。predict_core
- `limit_up_pct` / `limit_dn_pct`：涨跌停幅度（%），仅在 `limit_up/limit_down` 使用；默认 9.9 / -9.9。predict_core
- `lock_higher_than_open`：若为 True，强制 **收盘 ≥ 开盘**（生成完 O/C 后再修正）。predict_core
- `lock_inside_day`：若为 True，强制 **最高/最低** 把 O/C **包住**（生成 H/L 后，H=max(H,O,C)，L=min(L,O,C)）。predict_core

------

## 高低点生成（`hl_mode`）

决定“明日”的 **H/L** 怎么从上一日推演：

- `follow`：跟随上一日相对 **O/C** 的上下“余量”按比例外推；若某侧没空间给一个极小量（0.001）保证包含。
   直觉：保持昨天“相对振幅结构”，把它平移到新一天的 O/C 上。predict_core
- `atr_like`：用昨天振幅 `(H-L)` 乘 `atr_mult` 得出一个“目标振幅”，再以 **(O+C)/2** 为中点对称展开到 H/L。predict_core
- `range_pct`：目标振幅 = `max(O,C)` × `range_pct`% ，同样以 **(O+C)/2** 为中点对称展开。predict_core

配套参数：

- `atr_mult`：仅 `atr_like` 使用；例如 1.0 表示用昨振幅，2.0 表示放大一倍。predict_core
- `range_pct`（%）：仅 `range_pct` 使用；例如 2 表示 H/L 总振幅≈ 2%（围绕 (O+C)/2 对称）。predict_core

------

## 成交量（`vol_mode`）

决定“明日”的 **V**：

- `same`：沿用昨量（不变）。
- `pct`：V = 昨量 × (1 + `vol_arg`%)。
- `mult`：V = 昨量 × `vol_arg`（若传 0，内部按 1 处理）。
   以上三种模式都会做 **非负保护**：`max(V, 0.0)`。predict_core

> `vol_arg` 的含义取决于 `vol_mode`：在 `pct` 下是百分比（如 20=+20%），在 `mult` 下是倍数（如 1.5=放大50%）。predict_core

------

## 其他

- `warmup_days`：用于读取和指标重算的“历史窗口基准天数”；读取时实际上会回看约 `warmup_days*3` 个自然日来覆盖周末停牌，窗口越大，指标越稳，但计算更慢。predict_core predict_core
- （进阶）`PerStockOverride`：可按**个股**覆写上述任意字段（例如给 ST 股单独设置 `limit_up_pct`），规则里的 `scenario` 或 UI 的全局场景都能与之配合。predict_core

------

## 迷你示例

```
{
  "name": "放量突破近20日高点",
  "check": "HH:=HHV(H,20); VR:=SAFE_DIV(V,MA(V,20)); SIG:=(C>HH) AND (VR>=1.5);",
  "scenario": {
    "mode": "gap_then_close_pct",
    "gap_pct": -0.5,
    "pct": 2.0,
    "hl_mode": "atr_like",
    "atr_mult": 1.2,
    "vol_mode": "mult",
    "vol_arg": 1.5,
    "lock_higher_than_open": true,
    "warmup_days": 80
  }
}
```

- 开：先跳空 -0.5%，收：在开盘基础上再涨 2%；
- H/L：用昨振幅×1.2，对称展开；
- 量：在昨量基础上放大 1.5 倍；
- 收盘不低于开盘；读历史窗口按 80 天基准估。上述字段含义与实现逻辑对应到 `predict_core.py`。

# 持仓策略与表达式参考

## 能用哪些“词条”（变量）？

判定时系统会给你的表达式注入这些变量（数组，按时间序）：

- **价格量**：`OPEN, HIGH, LOW, CLOSE, V`（等价 O/H/L/C/VOL）。这是从“历史 +（可选）虚拟明日”拼好的序列。predict_core
- **环境**：`TS`（代码）、`REF_DATE`（判定目标日，若启用虚拟日则为模拟那一天）。predict_core
- **持仓相关**：`ENTRY_PRICE`（你上面输入或“策略取价”的买点）、`UNREAL_PNL`（用目标日收盘估的浮盈比例）。`UNREAL_PNL` 会在读取最后一根K线后自动算好：`(last_close-ENTRY_PRICE)/ENTRY_PRICE`。predict_core

> 如果你在 UI 勾选“基于明日虚拟日检查”，会先按你给的 **Scenario** 合成“明日一根 K”，再判定；否则只用历史到参考日。score_ui predict_core

## 表达式语法（类 TDX）

直接写 **布尔表达式** 或多行 TDX 片段（`A:=...;`），最后一行要能产生布尔序列；系统取**最后一个值**作为“是否触发”。常用函数/操作包括：`MA/EMA/SMA/LLV/HHV/SUM/STD/REF/CROSS/COUNT/IF/AND/OR/NOT/SAFE_DIV` 等（项目里的指标与规则已经在用这套写法）。predict_core indicators

## 可重算哪些指标列？

若你的表达式要用到已注册指标（如 `j/vr/bbi/diff/z_score/...`），可以在 UI 选择“全部/自选/不重算”，启用虚拟日时会把这些列重算后写回 df；不用虚拟日则只读历史基础列。稳妥做法是**在表达式里现算**（比如现场算 KDJ），就不依赖列了。score_ui predict_core indicators

## `POSITION_POLICIES` 的结构

```
POSITION_POLICIES = [
    {
        "name": "止损—跌破10日线",
        "when": "CLOSE < MA(CLOSE,10)",
        "explain": "收盘跌破10日均线"
    },
    {
        "name": "止盈—浮盈≥20%且回落",
        "when": "UNREAL_PNL >= 0.2 AND CLOSE < MA(CLOSE,5)",
        "explain": "浮盈≥20%回撤至5日线下"
    },
    {
        "name": "固定止损−8%",
        "when": "SAFE_DIV(CLOSE-ENTRY_PRICE, ENTRY_PRICE) <= -0.08",
        "explain": "相对买点回撤 8% 触发"
    },
    {
        "name": "加仓信号—放量站上20日",
        "when": "CROSS(MA(CLOSE,5), MA(CLOSE,20)) AND SAFE_DIV(V, MA(V,20)) >= 1.5",
        "explain": "5上20且量比≥1.5"
    }
]
```

- 这些就是 UI 里“持仓建议（个股）→ 选择策略 → 执行检查”的来源；系统会输出 `name / hit / explain / entry_price / unreal_pnl / ref_date / sim_date`。score_ui predict_core

## 进阶：买点来源 & 虚拟日

- **买点**可以三选一：按日期取开收高低、从 `OPPORTUNITY_POLICIES` 里“策略取价”、或手输；最终都会传给 `ENTRY_PRICE`。score_ui score_ui
- **虚拟日场景**（若勾选）使用和“明日预测”一致的 `Scenario` 字段（`mode/pct/gap_pct/hl_mode/atr_mult/range_pct/vol_mode/vol_arg/...`），你刚问过的那些词条在这里同样生效。score_ui
